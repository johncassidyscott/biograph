BioGraph — Master Spec (Investor-Grade / MVP)

Version: 8.3-MVP — 2026-01-19
Audience: Institutional investors, strategy, BD, competitive intelligence
Explicitly NOT: R&D discovery platform

This document is the single execution contract for the BioGraph MVP.
Anything not listed here is out of scope by default.

================================================================
0) One-line definition

BioGraph is an index-anchored intelligence graph that explains why a life-sciences issuer is moving, with auditable evidence.

================================================================
1) Product positioning (LOCKED)

FOR:
- Buy-side analysts (public markets)
- Strategy / BD / CI teams at biopharma and medtech
- Corporate development

NOT FOR:
- Bench scientists
- Bioinformatics teams
- Clinical statisticians
- IP lawyers

WHAT USERS PAY FOR:
- Issuer → DrugProgram → Target → Disease → Catalyst explanations
- Evidence chains that can be audited
- Time-aware answers ("what changed since last quarter?")
- Deterministic joins; no speculative graph traversal

================================================================
2) Universe & issuer identity (LOCKED)

INPUT:
- Human-curated Universe CSV (Phase 0) — DONE

ISSUER IDENTITY RULE (MVP):
- Issuer is an internal, stable identifier (issuer_id)
- CIK is an identifier, not the issuer itself
- One issuer may have multiple CIKs over time
- CIK changes, mergers, successor issuers handled manually in Phase 0
- No automated or fuzzy org resolution

CORE TABLES:

issuer(issuer_id, primary_cik, created_at, notes)

issuer_cik_history(
  issuer_id,
  cik,
  start_date,
  end_date,
  source,
  observed_at
)

universe_membership(
  issuer_id,
  universe_id,
  start_date,
  end_date,
  notes
)

================================================================
3) Scope gating (NON-NEGOTIABLE)

There is NO free graph traversal in MVP.

All product queries MUST conform to:

Issuer
  → DrugProgram
    → Target
      → Disease

Anything outside this chain does not exist in MVP.

================================================================
4) Fixed explanation chain (FIRST-CLASS)

The explanation chain is materialized and is the ONLY product query surface.

explanation(
  explanation_id,
  issuer_id,
  drug_program_id,
  target_id,
  disease_id,
  as_of_date,
  strength_score,
  created_at
)

RULES:
- UI and exports read ONLY from explanation objects
- Raw graph traversal is admin/debug-only
- Explanations are recomputed per as_of_date

================================================================
5) Canonical identity spine (LOCKED)

Issuer:
- Internal issuer_id
- Tracked via CIK history

Location:
- GeoNames ID

DrugProgram:
- Issuer-scoped internal ID
- Optional ChEMBL ID as attribute

Target:
- Open Targets stable ID

Disease:
- Open Targets stable ID

RULES:
- Missing required canonical ID → DISCARD
- No fuzzy joins
- All joins deterministic or curated

================================================================
6) Entity model (HARD-CAPPED)

ENTITIES (DO NOT ADD):
- Issuer
- Filing
- InsiderTransaction
- Exhibit
- Location
- DrugProgram
- Target
- Disease
- Evidence
- Assertion
- Explanation

EXPLICIT EXCLUSIONS:
- Pathways
- Variants
- Omics
- Trial arms
- Endpoints
- Patent claims
- Subsidiary-level legal entities

================================================================
7) DrugProgram definition (LOCKED)

DEFINITION:
A DrugProgram is an issuer-scoped therapeutic asset that satisfies at least ONE:
- Has a ChEMBL molecule ID, OR
- Is explicitly named in an SEC filing AND is linked to ≥1 Target and ≥1 Disease via evidence

ID SCHEME:
drug_program_id = "CIK:" + cik + ":PROG:" + slug

CONSTRAINTS:
- unique(issuer_id, slug)
- Always mint internal ID
- Cross-issuer program deduplication is OUT OF SCOPE for MVP

================================================================
8) Evidence-first data model (ENFORCED)

CORE PRINCIPLE:
No semantic relationship exists without evidence.

TABLES:

evidence(
  evidence_id,
  source_system,
  source_record_id,
  observed_at,
  retrieved_at,
  license,
  uri,
  checksum,
  snippet,
  confidence
)

assertion(
  assertion_id,
  subject_type,
  subject_id,
  predicate,
  object_type,
  object_id,
  asserted_at,
  retracted_at
)

assertion_evidence(
  assertion_id,
  evidence_id,
  weight,
  notes
)

RULES:
- Assertions REQUIRE ≥1 evidence record
- Missing evidence → DISCARD
- Graph edges are views over assertions (no direct edges)

================================================================
9) Data sources (COMMERCIAL-SAFE)

CORPORATE:
- SEC EDGAR (filings metadata, limited XBRL)
- SEC Form 4
- SEC Exhibit index (metadata only)

BIOMEDICAL (CONTEXT ONLY):
- Open Targets Platform (CC0)
- ChEMBL (CC BY-SA 3.0; attribution tracked)

ENRICHMENT:
- Wikidata (CIK joins only)
- GeoNames

================================================================
10) Open Targets scope lock (NON-NEGOTIABLE)

ALLOWED:
- Target identity
- Disease identity
- High-level target–disease associations
- Optional modality / tractability (context only)

DISALLOWED:
- Genetics
- Pathways
- Variant networks
- Propagated association scores

================================================================
11) Ingestion order (LOCKED)

Phase 0 — Universe (manual, DONE)
Phase 1 — Issuer + CIK lock
Phase 2 — Corporate spine (EDGAR)
Phase 3 — Enrichment (Wikidata, GeoNames)
Phase 4 — Asset mapping (DrugPrograms, Targets, Diseases)
Phase 5 — Evidence + Assertions
Phase 6 — Explanation materialization

INVARIANT:
No entity may be created unless all required upstream canonical IDs exist.

================================================================
12) Time semantics (EXPLICIT)

- Assertions are effective-dated:
  - asserted_at
  - optional retracted_at
- Explanations are computed AS-OF a date
- Enables "what changed since X?" queries

================================================================
13) Confidence scoring (DETERMINISTIC)

confidence =
  base_source_score
  + log(1 + evidence_count)
  + recency_bonus
  + curator_delta

All components are transparent and debuggable.

================================================================
14) Licensing gates (BUILD-BREAKER)

- Every evidence record MUST declare license
- Allowlist ONLY:
  - US Government (public domain)
  - CC0
  - CC BY-SA 3.0 (with attribution tracking)
- Missing or unknown license → DISCARD + ALERT

================================================================
15) Automation posture (BEST-IN-CLASS)

FULLY AUTOMATED:
- Exact CIK joins
- EDGAR metadata ingestion
- ChEMBL / Open Targets ID lookup
- GeoNames resolution

SEMI-AUTOMATED (ML SUGGESTS ONLY):
- NER tagging of filings (spaCy)
- Candidate DrugProgram mentions
- Duplicate name detection (Dedupe)

MANUAL (NON-NEGOTIABLE):
- Issuer identity decisions
- DrugProgram existence decisions
- Evidence acceptance / rejection
- Confidence overrides

ML may suggest. Humans decide.

================================================================
16) Storage stack (MVP)

SYSTEM OF RECORD:
- PostgreSQL

OPTIONAL (NOT MVP):
- pgvector
- Graph DBs (Neo4j) — only if traversal becomes necessary

================================================================
17) Quality gates (NON-NEGOTIABLE)

METRICS:
- ≥95% issuers have ≥1 DrugProgram
- ≥90% DrugPrograms have Target + Disease
- 100% assertions have evidence + license

DISCARD RULES:
- Out of universe
- Missing canonical ID
- Missing evidence
- Missing license

================================================================
18) Commercial novelty (LOCKED)

- Fixed explanation chains (no graph soup)
- Evidence-first, audit-grade model
- Index-anchored scope (investor-native)
- Deterministic ingestion
- Human-in-the-loop by design
- No R&D noise

This is Bloomberg-thinking applied to life sciences.

================================================================
END OF SPEC

================================================================
19) Artifact ingestion (EDGAR exhibits) — REQUIRED

Artifacts are first-class evidence inputs and MUST flow through the same
NER → mention → candidate → curation pipeline as filings.

SUPPORTED ARTIFACT TYPES (MVP):
- SEC EDGAR exhibits:
  - EX-10 (material contracts)
  - EX-99 (press releases attached to filings)
  - EX-21 (subsidiaries — metadata only)

NER SCOPE FOR ARTIFACTS:
- Run NER on:
  - exhibit title
  - exhibit description
  - publicly available exhibit text when exposed via EDGAR
- Generate:
  - evidence records
  - mentions
  - candidates (DrugProgram / Target / Disease)

ARTIFACT LINKAGE:
- Each artifact MUST link to:
  - issuer_id
  - parent filing_id
- Evidence.source_system = "SEC_EDGAR_EXHIBIT"

GUARDRAILS:
- Do NOT ingest full private contract text.
- Do NOT infer contractual terms or obligations.
- Only extract explicitly named entities.

================================================================
20) News metadata ingestion (MVP-safe)

News ingestion is METADATA-ONLY. This is NOT a news NLP product.

ALLOWED INPUTS:
- Publisher
- Headline
- Publication date
- URL
- Short snippet (ONLY if license permits)

DISALLOWED:
- Full article text
- Paywalled content
- Redistributed news bodies

NER SCOPE FOR NEWS:
- Run NER ONLY on:
  - headlines
  - permitted snippets
- Purpose:
  - candidate DrugProgram mentions
  - candidate issuer mentions (display only, NOT identity)
  - narrative correlation signals

EVIDENCE RULES:
- News evidence MAY NOT create assertions by itself.
- News may ONLY:
  - reinforce an assertion grounded in filings / Open Targets / ChEMBL
  - adjust confidence or recency signals

SOURCE HANDLING:
- Evidence.source_system = "NEWS_METADATA"
- License MUST be recorded.
- Unknown or incompatible license → DISCARD.

================================================================
21) Assertion priority rule (LOCKED)

Assertions may ONLY be created from:
1) SEC filings and EDGAR exhibits
2) Open Targets
3) ChEMBL

News metadata may NEVER be the sole source of an assertion.
It may only reinforce or contextualize an existing assertion.

================================================================
22) Linkage Confidence (User-Facing) — LOCKED

A) DEFINITION
Linkage Confidence = probability that the LINK (assertion) is correctly
resolved under BioGraph rules.

It is NOT:
- probability the biology is true
- probability a drug works
- investment recommendation confidence

Linkage confidence measures the quality of ENTITY RESOLUTION and
EVIDENCE-BACKED LINKAGE, not biological or clinical certainty.

B) SCOPE
- Confidence is shown ONLY for links surfaced in the explanation chain:
  Issuer → DrugProgram → Target → Disease

- Do NOT show confidence for unapproved candidates in the main product view.

- Candidates may show separate "suggestion confidence" in the curation
  queue only (different from linkage confidence).

C) UI REQUIREMENTS
Must show a confidence BAND for each link:
- HIGH (green)
- MEDIUM (yellow)
- LOW (orange/red)

Optionally expose numeric score in a details panel.

Always display:
- method: DETERMINISTIC | CURATED | ML_SUGGESTED_APPROVED
- short rationale bullets (drivers)
- evidence list (source + date + link)

D) DETERMINISTIC SCORING MODEL (LOCKED)

Score is computed deterministically from:
1. Method baseline:
   - DETERMINISTIC: 0.95
   - CURATED: 0.90
   - ML_SUGGESTED_APPROVED: 0.75

2. Evidence count bonus:
   - +0.01 per additional evidence source (capped)

3. Source tier weights:
   - SEC_EDGAR_FILING / SEC_EDGAR_EXHIBIT: up to +0.06
   - OPENTARGETS / CHEMBL: up to +0.05
   - NEWS_METADATA: up to +0.01 (never sole evidence)

4. Evidence agreement:
   - All evidence agrees: +0.02
   - Conflicting evidence: penalty

5. Small recency bonus (optional):
   - Recent evidence: +0.01

6. Curator delta (explicitly recorded, optional):
   - Curator can adjust ±0.05 with justification

CAPS (ENFORCED):
- DETERMINISTIC max: 0.99
- ML_SUGGESTED_APPROVED max: 0.85 (unless corroborated by deterministic ID match)

BANDS (LOCKED):
- HIGH: score >= 0.90
- MEDIUM: 0.75 <= score < 0.90
- LOW: score < 0.75

E) GUARDRAILS (LOCKED)

1. NEWS_METADATA can NEVER be the sole evidence for an assertion.

2. Every assertion used in explanations MUST have:
   - link_confidence_score (0.0 to 1.0)
   - link_confidence_band ('HIGH', 'MEDIUM', 'LOW')
   - link_method ('DETERMINISTIC', 'CURATED', 'ML_SUGGESTED_APPROVED')
   - link_rationale_json (method, evidence counts, caps applied, curator_delta)

3. Explanation materialization MUST validate confidence fields exist;
   fail loudly if missing.

4. Confidence is recomputed when:
   - Evidence is added/removed from assertion
   - Curator modifies confidence
   - Assertion is updated

F) RATIONALE JSON STRUCTURE

{
  "method": "DETERMINISTIC",
  "evidence_count": 3,
  "evidence_by_source": {
    "sec_edgar": 2,
    "opentargets": 1
  },
  "base_score": 0.95,
  "evidence_bonus": 0.02,
  "source_bonus": 0.06,
  "agreement_bonus": 0.02,
  "recency_bonus": 0.00,
  "curator_delta": 0.00,
  "caps_applied": ["deterministic_cap_0.99"],
  "final_score": 0.99,
  "band": "HIGH"
}

================================================================
23) Data Retention & Resolution Posture (Thin Durable Core) — LOCKED

A) PRINCIPLE

Persist only what is required for:
- Auditability (who, what, when, why)
- Reproducibility / time-travel (historical queries)
- Deterministic joins (stable IDs)
- Fast, stable product queries (explanation table)

Resolve everything else LIVE or via a small, disposable cache.

This posture minimizes complexity, storage, and operational overhead while
preserving investor-grade trust and audit trail.

B) MUST PERSIST LOCALLY (TRUTH + AUDIT)

The following tables are REQUIRED and constitute the durable core:

1. **Universe / Issuer Identity**:
   - issuer
   - issuer_cik_history
   - universe_membership
   - company (SEC metadata)

2. **Evidence** (metadata + bounded snippet):
   - evidence (with snippet max ~1-2K characters)
   - license_allowlist
   - confidence_rubric

3. **Assertions + Links**:
   - assertion
   - assertion_evidence
   - Drug program entities (drug_program, drug_program_alias)

4. **Explanations** (materialized query surface):
   - explanation
   - explanation_refresh_log

5. **Operational NLP**:
   - nlp_run
   - mention
   - candidate
   - duplicate_suggestion (optional, within-issuer only)

6. **Corporate Data** (EDGAR metadata):
   - filing (metadata only)
   - insider_transaction
   - exhibit (metadata only, NOT full text)

C) RESOLVE LIVE OR CACHE LIGHTLY (LABELS + ENRICHMENT)

The following data is NOT stored in bulk. Instead, store stable IDs locally
and resolve labels/enrichment on-demand:

1. **OpenTargets**:
   - Store target_id (Ensembl ID) in target table
   - Store disease_id (EFO/MONDO ID) in disease table
   - Resolve labels LIVE via GraphQL API:
     - target name
     - gene symbol
     - disease name
     - therapeutic area
   - Cache results in lookup_cache (TTL: 30 days)

2. **ChEMBL**:
   - Store chembl_id as attribute in drug_program
   - Resolve labels LIVE via REST API:
     - preferred name
     - molecule type
   - Cache results in lookup_cache

3. **GeoNames**:
   - Store geonames_id in location references
   - Resolve labels LIVE via API:
     - place name
     - country code
   - Cache results in lookup_cache

4. **Wikidata**:
   - Minimal enrichment only (via CIK join)
   - No bulk dumps
   - Resolve via SPARQL if needed (rare)

D) LOOKUP CACHE TABLE (REQUIRED)

Define a lightweight, disposable cache for ID-to-label lookups:

CREATE TABLE lookup_cache (
    cache_key       TEXT PRIMARY KEY,      -- Format: "{source}:{id}"
    source          TEXT NOT NULL,          -- 'opentargets', 'chembl', 'geonames', 'wikidata'
    value_json      JSONB NOT NULL,         -- Cached data (label, metadata)
    fetched_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at      TIMESTAMPTZ NOT NULL,   -- TTL enforcement
    hit_count       INTEGER DEFAULT 0,
    last_hit_at     TIMESTAMPTZ
);

Rules:
- Cache is DISPOSABLE (can be dropped and rebuilt anytime)
- Cache is NOT truth (truth is in assertions + evidence)
- Default TTL: 30 days
- Cache only ID → label style lookups, NOT bulk data
- On cache miss: fetch live, cache result, return
- On live fetch failure: return ID as fallback label

E) EXPLICITLY FORBIDDEN BULK INGESTION

The following are FORBIDDEN in MVP:

1. OpenTargets full datasets:
   - No bulk download of target catalogs
   - No bulk download of disease ontologies
   - No bulk download of associations

2. ChEMBL synonym universes:
   - No bulk download of compound tables
   - No bulk download of synonym tables

3. GeoNames dumps:
   - No bulk download of place databases

4. Wikidata dumps:
   - No bulk download of entity dumps

Rationale:
- Minimizes storage (GB → MB)
- Minimizes ingestion complexity
- Reduces operational burden
- Live resolution is fast enough for MVP scale

F) EDGAR TEXT RETENTION POLICY (LOCKED)

1. **Metadata** (ALWAYS PERSIST):
   - filing table: accession_number, filing_date, form_type, items_8k, edgar_url
   - exhibit table: exhibit_id, accession_number, exhibit_type, description, edgar_url

2. **Text Snippets** (BOUNDED):
   - Store in evidence.snippet (max ~1-2K characters)
   - Purpose: human-readable context for assertions
   - NOT full text extraction

3. **FORBIDDEN**:
   - Full contract text
   - Full 10-K text
   - Paywalled content
   - Any text exceeding snippet bounds

4. **ALWAYS STORE**:
   - Canonical EDGAR URL (evidence.uri)
   - Checksum (evidence.checksum) for verification

Rationale:
- Minimizes storage
- Avoids copyright/license issues
- Preserves auditability (URL + checksum)
- Snippet sufficient for human review

G) PIPELINE CONSOLIDATION (OPERATIONAL GUIDANCE)

While the spec defines conceptual phases (0-6), implementation MAY consolidate
these into operational commands for simplicity:

Suggested Commands:
1. `ingest-universe` — Phase 0 (universe membership)
2. `ingest-edgar` — Phase 1-2 (CIK validation + filings + exhibits)
3. `ingest-enrichment` — Phase 3 (Wikidata via CIK, minimal)
4. `nlp-run` — Phase 4 (NER on filings/exhibits/news)
5. `curate` — Phase 5 (accept/reject candidates → canonical)
6. `materialize` — Phase 6 (explanations)

Conceptual phases remain for reasoning. Operational complexity should be
minimized.

H) LIVE RESOLUTION BEHAVIOR (REQUIRED)

1. **API Queries**:
   - Query explanation table from Postgres (fast, local)
   - Retrieve assertion IDs and entity IDs
   - Resolve labels AFTER retrieval via resolvers
   - Return to client

2. **Resolver Functions** (biograph/integrations/):
   - get_target_label(target_id) → cached or live
   - get_disease_label(disease_id) → cached or live
   - get_chembl_label(chembl_id) → cached or live
   - get_geonames_label(geonames_id) → cached or live

3. **Failure Handling**:
   - If cache hit: return cached value
   - If cache miss: fetch live, cache, return
   - If live fetch fails: log warning, return ID as label (fallback)
   - API MUST remain functional if live resolution fails

4. **Linkage Confidence Isolation**:
   - Linkage confidence is computed ONLY from:
     - method (DETERMINISTIC, CURATED, ML_SUGGESTED_APPROVED)
     - evidence (count, sources, tiers)
     - assertions (structure)
   - Live-resolved labels MUST NOT affect confidence scores or bands
   - Live resolution is presentation layer ONLY, not truth layer

I) TESTING REQUIREMENTS (ENFORCED)

1. **No Bulk Ontology Tables**:
   - Contract test: Assert no large OT/ChEMBL/GeoNames catalog tables exist
   - Contract test: Assert target/disease tables only contain entities
     referenced by assertions (not full catalogs)

2. **Lookup Cache Functionality**:
   - Test cache hit: Second resolver call uses cache
   - Test cache miss: First call fetches live and caches
   - Test cache expiry: Expired entries trigger refetch

3. **API Stability Without Live Resolution**:
   - Test: Explanation API returns successfully even if live resolver fails
   - Test: Fallback to ID as label when live fetch fails

4. **Confidence Isolation**:
   - Test: Linkage confidence does not change when labels are resolved
   - Test: Confidence computation does not call resolvers

J) BENEFITS OF THIN DURABLE CORE

1. **Storage**: GB → MB (10-100x reduction)
2. **Complexity**: Fewer ingestion pipelines
3. **Freshness**: Labels always up-to-date (no stale catalogs)
4. **Operational**: Simpler backup/restore (smaller DB)
5. **Auditability**: Unchanged (evidence + assertions remain)
6. **Reproducibility**: Unchanged (stable IDs + time-travel)
7. **Performance**: Faster for MVP scale (<1000 issuers)

K) MIGRATION PATH (EXISTING DEPLOYMENTS)

If bulk ontology tables exist from earlier versions:
1. Identify entities referenced by assertions
2. Populate lookup_cache from existing tables
3. Drop bulk ontology tables
4. Enable live resolution
5. Verify API functionality
6. Monitor cache hit rates

================================================================
24) Literature and News Evidence (Metadata-Only) — LOCKED

A) PUBMED LITERATURE (REQUIRED)

SCOPE:
PubMed provides scientific literature evidence for drug-target-disease
relationships. PubMed evidence is METADATA-ONLY to comply with copyright
and Thin Durable Core principles.

INGESTION RULES:
Ingest PubMed METADATA ONLY:
- PMID (PubMed ID)
- title
- journal
- publication_date
- MeSH IDs (Medical Subject Headings)
- DOI (if present)
- PubMed URL

FORBIDDEN:
- Full text extraction
- PDF downloads
- Abstract text (unless <200 chars snippet)
- Author lists (optional: first author only)

EVIDENCE CREATION:
Create evidence records:
- source_system = 'pubmed'
- source_record_id = PMID (e.g., '12345678')
- license = 'NLM_PUBLIC' (National Library of Medicine)
- uri = PubMed URL (https://pubmed.ncbi.nlm.nih.gov/{PMID})
- snippet = title (max 200 chars)

ASSERTION SUPPORT RULE (LOCKED):
PubMed evidence may SUPPORT assertions but may NEVER be the sole evidence.

- Valid: SEC filing + PubMed = assertion ✓
- Valid: OpenTargets + PubMed = assertion ✓
- Invalid: PubMed alone = assertion ✗

Rationale: Scientific literature describes research findings, not corporate
commitments. Assertions must be grounded in authoritative sources (SEC,
OpenTargets, ChEMBL).

B) MeSH USAGE (LOCKED)

PRINCIPLE:
MeSH (Medical Subject Headings) provides disease classification.
Use MeSH to map diseases to Therapeutic Areas (TAs).
Do NOT bulk ingest MeSH hierarchy.

STORAGE:
- Store MeSH IDs as provided by PubMed (in evidence or separate linking table)
- Do NOT store full MeSH tree or synonym catalogs
- Resolve MeSH labels and tree positions via resolver + cache

RESOLUTION:
- Implement mesh resolver (biograph/integrations/mesh.py)
- Fetch MeSH descriptor data from NLM API (or local allowlist)
- Cache MeSH ID → {label, tree_numbers[]} in lookup_cache
- TTL: 90 days (MeSH updates yearly)

MESH TREE STRUCTURE:
MeSH uses hierarchical tree codes (e.g., 'C04.557.470' = lung cancer).
Tree prefixes map to disease categories:
- C04 = Neoplasms
- C10 = Nervous System Diseases
- C14 = Cardiovascular Diseases
- C20 = Immune System Diseases
- etc.

Use tree prefixes to map diseases to Therapeutic Areas.

C) THERAPEUTIC AREA TAXONOMY (USER-FACING)

DEFINITION:
Therapeutic Area (TA) = high-level disease category for investor/user navigation.
BioGraph uses a FIXED, small taxonomy of 8 TAs (locked):

1. ONC (Oncology) — Cancer
2. IMM (Immunology) — Autoimmune, inflammation
3. CNS (Central Nervous System) — Neurology, psychiatry
4. CVM (Cardiovascular/Metabolic) — Heart, diabetes, obesity
5. ID (Infectious Disease) — Viral, bacterial, fungal
6. RARE (Rare Disease) — Orphan diseases
7. RES (Respiratory) — Lung, asthma, COPD
8. REN (Renal) — Kidney diseases

MAPPING RULES:
Each disease maps to exactly ONE primary TA.
Mapping is deterministic and auditable.

TA Mapping Strategy:
1. If disease has MeSH IDs from PubMed → use MeSH tree mapping
2. If disease has EFO/MONDO ID from OpenTargets → use curated TA map
3. If no metadata → default to 'UNKNOWN'

TA mapping MUST be:
- Deterministic (same input → same output)
- Auditable (log mapping source)
- Stable (changes require migration)

MESH → TA MAPPING TABLE (CURATED):
Define MeSH tree prefix anchors for each TA:

ONC:
- C04* (Neoplasms)

IMM:
- C20* (Immune System Diseases)
- C17.300* (Autoimmune Diseases)

CNS:
- C10* (Nervous System Diseases)
- F03* (Mental Disorders)

CVM:
- C14* (Cardiovascular Diseases)
- C18.452* (Metabolic Diseases)
- E11* (Diabetes Mellitus)

ID:
- C01* (Bacterial Infections)
- C02* (Virus Diseases)
- C03* (Parasitic Diseases)

RARE:
- (Curated list of rare disease MeSH/EFO IDs)

RES:
- C08* (Respiratory Tract Diseases)

REN:
- C12.777* (Kidney Diseases)
- C13* (Urologic Diseases)

MULTI-TA RESOLUTION:
If disease maps to multiple TAs (e.g., inflammatory lung disease → IMM vs RES):
- Choose MOST SPECIFIC TA based on tree depth
- Record secondary TAs for reference
- Primary TA is used for UI filtering

D) NEWS METADATA (MVP-SAFE)

SCOPE:
News provides market context (press releases, media coverage).
News is METADATA-ONLY and has ZERO assertion-creating power.

INGESTION RULES:
Ingest news METADATA ONLY:
- publisher (e.g., 'Bloomberg', 'Reuters')
- headline
- publication_date
- URL
- optional: snippet (max 200 chars)

FORBIDDEN:
- Full article text
- Paywalled content
- Images/videos

NER USAGE:
NER may run on headline and snippet to extract:
- Drug program mentions
- Issuer mentions (display context only, NOT identity)
- Disease mentions (narrative signals only)

NER output creates CANDIDATES, never canonical entities.

EVIDENCE CREATION:
Create evidence records:
- source_system = 'news_metadata'
- source_record_id = URL hash or news_item_id
- license = 'UNKNOWN' or publisher's terms
- uri = news URL
- snippet = headline (max 200 chars)

ASSERTION SUPPORT RULE (LOCKED - UNCHANGED):
News evidence may NEVER be the sole evidence for an assertion.
News may ONLY:
- Reinforce existing assertions grounded in SEC/OpenTargets/ChEMBL
- Affect recency signals in confidence scoring
- Provide narrative context for display

News evidence:
- Cannot create assertions
- Cannot determine TA
- Cannot validate drug programs
- Cannot establish target-disease links

E) IMPLEMENTATION REQUIREMENTS

1) DATABASE SCHEMA:
- news_item table (metadata storage)
- pubmed_article table (optional, or use evidence.source_record_id)
- therapeutic_area_mapping table (TA anchor definitions)

2) RESOLVERS:
- biograph/integrations/pubmed.py
- biograph/integrations/mesh.py

3) CORE LOGIC:
- biograph/core/therapeutic_area.py (TA mapping)

4) API SURFACING:
- Surface TA per disease/drug program
- Surface PubMed evidence as "Scientific context"
- Surface news evidence as "Media coverage"
- Do NOT surface raw MeSH codes to users (use labels)

F) TESTING REQUIREMENTS (ENFORCED)

1) PubMed Metadata Only:
- Assert no full text stored
- Assert snippet ≤ 200 chars

2) PubMed Not Sole Evidence:
- Assert assertions cannot rely only on PubMed
- Contract test: PubMed-only assertion creation fails

3) TA Mapping Deterministic:
- Same MeSH input → same TA output
- Test mapping for each TA category

4) News Never Creates Assertion:
- Contract test: News-only assertion creation fails
- News can only reinforce existing assertions

5) MeSH Thin Core:
- Assert no bulk MeSH tree tables
- Assert MeSH labels resolved via cache

G) BENEFITS

1) Scientific Context:
- PubMed provides peer-reviewed evidence
- Increases confidence in drug-target-disease links

2) User Navigation:
- Therapeutic Areas enable filtering by disease category
- Investors can focus on specific therapeutic focus areas

3) Market Context:
- News provides real-time market signals
- Track media coverage of programs

4) Thin Durable Core Preserved:
- No bulk MeSH ingestion (resolve live)
- No full text storage (metadata only)
- Storage remains minimal

H) CONSTRAINTS (LOCKED)

1) PubMed evidence alone CANNOT create assertions
2) News evidence alone CANNOT create assertions
3) MeSH bulk catalogs FORBIDDEN (resolve live)
4) Full text ingestion FORBIDDEN
5) TA taxonomy is FIXED (8 categories)
6) TA mapping is DETERMINISTIC (auditable)
7) News cannot determine TA or validate entities

================================================================
25) Storage & Projection Architecture (DUAL-LAYER) — LOCKED

RATIONALE:
- Prior implementations showed Postgres too slow for relationship-heavy explanation queries
- Neo4j provides significant performance gains for graph traversal at scale
- Fixed-chain constraint preserves product semantics and prevents graph drift
- This is an intentional, MVP-safe optimization that does NOT relax auditability

A) SYSTEM OF RECORD (AUTHORITATIVE)

Postgres (Neon) is the SOLE SOURCE OF TRUTH.

ALL canonical data lives ONLY in Postgres:
- universe / issuer identity
- canonical entities (target, disease, molecule, location)
- evidence records (source_system, source_record_id, license, uri, snippet)
- assertions (subject, predicate, object) + assertion_evidence
- curation decisions and queues
- explanation materializations
- linkage confidence computations
- licensing metadata
- audit logs and time-travel queries

POSTGRES RESPONSIBILITIES:
1. Write path: ALL writes go to Postgres first
2. Auditability: Evidence chains and provenance queries
3. Time-travel: Historical queries (as_of_date)
4. Licensing: Evidence license verification
5. Confidence: Linkage confidence computation
6. Curation: Entity resolution, assertion approval
7. Source of truth: Canonical entity IDs and relationships

POSTGRES IS NEVER OPTIONAL.

B) GRAPH PROJECTION LAYER (NON-AUTHORITATIVE)

Neo4j (Aura) is used as a READ-OPTIMIZED PROJECTION.

Neo4j stores DERIVED data only.
Neo4j may be dropped and rebuilt at any time without data loss.

WHAT IS PROJECTED TO NEO4J (MVP-SAFE):

Nodes (by canonical ID only):
- Issuer (issuer_id)
- DrugProgram (drug_program_id)
- Target (target_id)
- Disease (disease_id)

Relationships (fixed shape only):
- (Issuer)-[:HAS_PROGRAM]->(DrugProgram)
- (DrugProgram)-[:TARGETS]->(Target)
- (Target)-[:INDICATED_FOR]->(Disease)

Node properties (metadata only):
- canonical ID (primary key)
- label (resolved live or cached, not authoritative)
- as_of_date (temporal context)

Relationship properties (summary only):
- as_of_date
- confidence_band (HIGH, MEDIUM, LOW)
- confidence_score (optional, for sorting)
- link_method (DETERMINISTIC, CURATED, ML_SUGGESTED_APPROVED)
- evidence_count (integer count only, not text)
- assertion_ids (array of assertion IDs for Postgres lookup)

NEO4J RESPONSIBILITIES:
1. Fast path: Optimized graph queries for explanation retrieval
2. Learning: Performance experimentation and query optimization
3. Projection: Derived view of Postgres data
4. Disposable: Can be rebuilt from Postgres at any time

C) EXPLICITLY FORBIDDEN IN NEO4J

Neo4j NEVER:
1. Creates assertions
2. Resolves entities (ER/NER)
3. Stores evidence text or snippets
4. Stores licensing data
5. Stores curation queues
6. Computes linkage confidence
7. Acts as write-back to Postgres
8. Enables free traversal beyond fixed explanation paths
9. Stores any data not derivable from Postgres

WRITE-BACK RULE (LOCKED):
Neo4j mutations NEVER propagate back to Postgres.
Neo4j is READ-ONLY from application perspective.

D) QUERY ROUTING RULES

UI / API MAY read explanation edges from Neo4j for speed:
- Issuer → DrugProgram → Target → Disease traversal
- Filtering by confidence band, as_of_date, link method
- Sorting by confidence score

Evidence, provenance, and audit details MUST be fetched from Postgres by ID:
- Evidence text, snippets, URIs
- Source system, license information
- Full assertion details
- Historical queries (time-travel)
- Curation decisions

FALLBACK RULE (REQUIRED):
If Neo4j is unavailable, API MUST transparently fall back to Postgres.
System remains fully functional with Postgres-only path.

E) PROJECTION STRATEGY (ONE-WAY)

Postgres → Neo4j projection is ONE-WAY.

Projector reads from:
- explanation table (materialized view in Postgres)
- assertion + assertion_evidence (for confidence metadata)

Projector writes to:
- Neo4j nodes (Issuer, DrugProgram, Target, Disease)
- Neo4j relationships (HAS_PROGRAM, TARGETS, INDICATED_FOR)

Projection trigger:
- MVP: Manual rebuild command (per issuer or per as_of_date)
- Future: Event-driven incremental updates (not required for MVP)

Projection lag:
- Logged but does not block writes
- API falls back to Postgres if projection is stale

Idempotency:
- Projector may be run multiple times safely
- Upsert semantics (MERGE in Neo4j)

F) CONFIGURATION

Required environment variables:
- GRAPH_BACKEND=postgres|neo4j (default: postgres)
- NEO4J_URI (e.g., neo4j+s://xxx.databases.neo4j.io)
- NEO4J_USER
- NEO4J_PASSWORD

Safe mode:
- GRAPH_BACKEND=postgres (default)
- System runs entirely on Postgres
- Neo4j is opt-in performance optimization

G) ABSTRACTION LAYER

ExplanationStore interface (abstract):
- get_explanation(issuer_id, as_of_date) → explanation graph
- get_assertion_details(assertion_id) → assertion + evidence
- get_evidence(evidence_id) → evidence record

Implementations:
1. PostgresExplanationStore (authoritative, always available)
2. Neo4jExplanationStore (fast path, optional)

API query flow:
1. Try Neo4j (if enabled) → get explanation graph
2. Fall back to Postgres (if Neo4j unavailable)
3. Fetch evidence details from Postgres by ID (always)

H) CONSTRAINTS (LOCKED)

1) Postgres is the ONLY source of truth
2) Neo4j stores DERIVED data only (can be rebuilt)
3) Neo4j NEVER writes back to Postgres
4) Evidence text NEVER stored in Neo4j
5) Licensing data NEVER stored in Neo4j
6) Confidence computation ONLY in Postgres
7) Free traversal beyond fixed paths FORBIDDEN
8) API MUST work with Postgres-only (Neo4j optional)
9) Projection is ONE-WAY (Postgres → Neo4j)
10) Projection lag does NOT block writes

I) TESTING REQUIREMENTS

Contract tests (non-negotiable):
1. test_postgres_is_source_of_truth:
   - Assertions/evidence exist in Postgres regardless of Neo4j state
2. test_neo4j_projection_matches_postgres:
   - Explanation edge counts and IDs match for known issuer/as_of_date
3. test_no_write_back_from_neo4j:
   - Neo4j mutations never affect Postgres
4. test_fallback_to_postgres:
   - API works when Neo4j is disabled (GRAPH_BACKEND=postgres)
5. test_evidence_only_in_postgres:
   - Evidence text/licensing NEVER in Neo4j
6. test_confidence_only_in_postgres:
   - Confidence scores computed in Postgres, projected to Neo4j

J) RATIONALE (WHY DUAL-LAYER)

Performance necessity:
- Postgres relationship queries too slow for explanation retrieval at scale
- Neo4j provides 10-100x speedup for graph traversal
- User experience requires sub-second response times

Safety preserved:
- Fixed-chain constraint prevents graph drift
- Postgres remains source of truth
- Neo4j is disposable (can be rebuilt)
- Auditability unaffected (evidence always in Postgres)

MVP-safe:
- Start with Postgres-only (safe default)
- Add Neo4j when performance needed
- Fallback ensures system always works
- No write-back prevents data inconsistency

Learning layer:
- Neo4j enables query optimization experiments
- Performance tuning without affecting Postgres
- Projection strategy can evolve (manual → incremental → event-driven)

K) IMPLEMENTATION PHASES

Phase 1 (PR1): Spec + Abstraction + Postgres Path
- Update spec to v8.3
- Create ExplanationStore interface
- Implement PostgresExplanationStore
- Add GRAPH_BACKEND configuration
- Contract tests for Postgres-only path

Phase 2 (PR2): Neo4j Schema + Projector
- Define Neo4j schema (nodes, relationships, properties)
- Implement Neo4jProjector (Postgres → Neo4j)
- Implement rebuild command (per issuer / per as_of_date)
- Contract tests for projection correctness

Phase 3 (PR3): API Fast-Path + Fallback
- Implement Neo4jExplanationStore
- Add query routing (Neo4j → Postgres fallback)
- Add projection lag monitoring
- Contract tests for fallback behavior

================================================================
26) Execution Layer (Not Research-Grade) — LOCKED

CRITICAL REQUIREMENT:
BioGraph MVP must be deployable as a hosted service with production-grade execution.

This is NOT:
- A notebook-driven prototype
- A collection of alternate apps/frameworks
- An R&D pipeline demo
- A multi-framework experiment
- A research codebase

This IS:
- An investor-grade intelligence product
- A commercially-viable hosted POC
- A deterministic, reproducible system
- A secure-by-default application

A) DEPLOYMENT REQUIREMENTS

BioGraph MVP must be deployable as a hosted service with:
1. Single API entry point (no ambiguity about which server to run)
2. Deterministic behavior (same inputs → same outputs)
3. Reproducible builds (locked dependencies, versioned migrations)
4. Security controls (API key auth, no public admin endpoints)
5. Robust error handling (no stack traces to clients)
6. Performance safeguards (connection pooling, timeouts)
7. Contract tests as non-negotiable gates (CI must be green)

B) OPERATIONAL STANDARDS

The system must demonstrate:
- Health monitoring (/healthz endpoint required)
- Structured logging (JSON logs with request_id)
- Database connection pooling (no per-request TCP connections)
- Error sanitization (no internal details exposed)
- API versioning (clear /api/v1/ namespace)
- Dependency hygiene (no unused imports, no missing requirements)

C) ACCEPTANCE CRITERIA

The MVP is NOT shippable until:
- Exactly ONE API entrypoint exists and is deployed
- CI is green (migrations + contract tests + full test suite)
- Admin/curation endpoints are API-key gated
- Connection pooling is enabled
- Errors are sanitized and structured
- /healthz endpoint works and verifies dependencies
- NER/ER are not stubs (minimum viable implementations exist)

================================================================
27) Single API Runtime — LOCKED

REQUIREMENT:
BioGraph MVP must have exactly ONE production API runtime.

A) FRAMEWORK LOCK

FastAPI is the SOLE supported API runtime in MVP.

Rationale:
- Type safety (Pydantic request/response validation)
- Auto-generated OpenAPI documentation (/docs, /openapi.json)
- Async support (better performance than Flask)
- Modern Python idioms (async/await, type hints)

Flask, Django, or other frameworks are FORBIDDEN in production code.

B) SINGLE ENTRY POINT

Exactly ONE runnable server module exists:
- biograph/api/main.py (production entrypoint)

Legacy entrypoints MUST be:
- Deleted (preferred), OR
- Quarantined (moved to /legacy/ directory, not imported, not runnable, not referenced by deploy config)

C) URL VERSIONING

All endpoints are under /api/v1/*

Examples:
- GET /api/v1/issuers
- GET /api/v1/explanation/{issuer_id}
- GET /api/v1/search

Forbidden:
- /api/v8_* naming (internal spec version does NOT dictate URL versioning)
- Unversioned paths like /api/issuers (no /v1/ prefix)
- Multiple version namespaces (/v1/ and /v2/ simultaneously in MVP)

D) OPENAPI DOCUMENTATION

Must expose:
- GET /docs (Swagger UI)
- GET /openapi.json (OpenAPI schema)

Access control:
- In non-production: Public access to /docs
- In production: API-key gated OR disabled via environment variable

E) REMOVE AMBIGUITY

The following files MUST NOT exist or be importable:
- /app.py (Flask minimal app)
- /app_mvp.py (FastAPI alternate)
- /backend/app/main.py (FastAPI alternate)
- /backend/app/main_mvp.py (unknown purpose)
- /backend/app/api_mvp.py (unknown purpose)

Only ONE of these survives:
- /biograph/api/main.py (recommended)

Deployment config (render.yaml, Dockerfile) MUST reference only the canonical entrypoint.

================================================================
28) Access Control (POC-Grade, Required) — LOCKED

CRITICAL REQUIREMENT:
This MVP MUST NOT expose admin or raw data endpoints publicly.

A) MINIMUM AUTHENTICATION

API key authentication using header: X-API-Key

Required for:
- Any admin endpoints (/api/v1/admin/*)
- Any curation endpoints (/api/v1/curation/*)
- Any endpoint returning raw assertions (assertion table rows)
- Any endpoint returning raw evidence bodies
- Any endpoint returning operational tables (nlp_run, candidate, etc.)

Optional (configurable) for read endpoints:
- If hosted publicly: ALL endpoints require API key
- If demo mode: Read endpoints MAY be public BUT must exclude:
  - Raw assertion/evidence bodies (unless API key present)
  - Admin/curation data
  - Internal operational tables

B) API KEY IMPLEMENTATION

Simple API key verification:
1. API keys stored in environment variable or database table
2. Header validation: X-API-Key must match known key
3. Return 401 Unauthorized if missing or invalid
4. Return 403 Forbidden if valid but insufficient permissions

Example implementation:
```python
from fastapi import Header, HTTPException

async def verify_api_key(x_api_key: str = Header(None)):
    if not x_api_key:
        raise HTTPException(status_code=401, detail="API key required")
    if x_api_key not in VALID_API_KEYS:
        raise HTTPException(status_code=401, detail="Invalid API key")
    return x_api_key

@router.get("/api/v1/admin/assertions")
async def list_assertions(api_key = Depends(verify_api_key)):
    # Protected endpoint
    ...
```

C) OUT OF SCOPE FOR MVP

The following are NOT required for MVP but system must be structured to add later:
- User registration/login UI
- JWT token generation/refresh
- Password hashing and user accounts
- Multi-tenant RBAC (role-based access control)
- OAuth integration
- Session management

D) FUTURE-PROOFING

Auth layer must be designed such that:
- Adding user accounts later does NOT require schema refactor
- API key → JWT migration is straightforward
- RBAC can be layered on top of API keys

E) DEPLOYMENT MODES

Environment variable: AUTH_MODE
- "api_key" (default): Require X-API-Key header
- "demo" (unsafe): Read endpoints public, admin endpoints still require key
- "disabled" (local dev only): No auth (NEVER use in hosted deployment)

================================================================
29) Database Connection Management — LOCKED

REQUIREMENT:
Use connection pooling. No per-request TCP connections.

A) CONNECTION POOLING REQUIRED

Use psycopg_pool (or equivalent) to manage database connections.

Pool is created ONCE at application startup.
Requests MUST reuse pooled connections.

B) IMPLEMENTATION

```python
from psycopg_pool import ConnectionPool
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: create pool
    app.state.pool = ConnectionPool(
        conninfo=DATABASE_URL,
        min_size=5,
        max_size=20,
        timeout=10.0
    )
    yield
    # Shutdown: close pool
    app.state.pool.close()

app = FastAPI(lifespan=lifespan)

async def get_db():
    """Dependency to get DB connection from pool."""
    with app.state.pool.connection() as conn:
        yield conn
```

C) POOL CONFIGURATION

Pool size MUST be configurable via environment variables:
- DB_POOL_MIN_SIZE (default: 5)
- DB_POOL_MAX_SIZE (default: 20)
- DB_POOL_TIMEOUT (default: 10.0 seconds)

D) HEALTH CHECKS

Pool health MUST be checked:
- On startup (fail fast if DB unreachable)
- In /healthz endpoint (report pool status)

E) FORBIDDEN PATTERNS

The following pattern is FORBIDDEN:
```python
# WRONG: Creates new connection on every request
@contextmanager
def get_conn():
    conn = Connection.connect(DATABASE_URL)
    try:
        yield conn
    finally:
        conn.close()
```

This will exhaust database connections under concurrent load.

================================================================
30) Error Handling & Safe Responses — LOCKED

REQUIREMENT:
API must NEVER return raw stack traces to clients.

A) STRUCTURED ERROR FORMAT

All errors MUST return JSON in this format:
```json
{
  "error": {
    "code": "database_unavailable",
    "message": "Service temporarily unavailable",
    "request_id": "req_abc123"
  }
}
```

B) STATUS CODES

Use proper HTTP status codes:
- 400 Bad Request: Validation errors (bad input)
- 401 Unauthorized: Missing or invalid API key
- 403 Forbidden: Valid API key but insufficient permissions
- 404 Not Found: Resource not found
- 429 Too Many Requests: Rate limit exceeded (if enabled)
- 503 Service Unavailable: Dependency outages (DB down, Neo4j down)
- 500 Internal Server Error: Unexpected errors (no internals exposed)

C) ERROR HANDLING MIDDLEWARE

All endpoints MUST be wrapped in error handling:
```python
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    request_id = request.headers.get("X-Request-ID", "unknown")

    # Log with full context
    logger.error(
        "Unhandled exception",
        exc_info=exc,
        request_id=request_id,
        path=request.url.path
    )

    # Return sanitized error to client
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "internal_error",
                "message": "An unexpected error occurred",
                "request_id": request_id
            }
        }
    )
```

D) LOGGING

Structured logs (JSON) with context:
- request_id (for tracing)
- endpoint name
- user_id (if authenticated)
- error details (in logs only, NOT in response)

Example:
```python
logger.error(
    "database.connection.failed",
    request_id=request_id,
    endpoint="list_issuers",
    user_id=user_id,
    exc_info=e
)
```

E) FORBIDDEN

The following is FORBIDDEN:
```python
# WRONG: Exposes stack trace to client
@router.get("/api/v1/issuers")
async def list_issuers():
    cur.execute(query)  # If fails: 500 with full traceback
    return cur.fetchall()
```

All endpoints MUST have try/except blocks.

================================================================
31) Required Operational Endpoints — LOCKED

REQUIREMENT:
The API MUST expose operational health endpoints.

A) HEALTH CHECK (REQUIRED)

GET /healthz

Returns status of:
- Postgres connectivity (REQUIRED)
- Neo4j connectivity (if GRAPH_BACKEND=neo4j)
- Lookup cache readiness (REQUIRED)

Response format:
```json
{
  "status": "healthy",
  "checks": {
    "postgres": {
      "status": "up",
      "latency_ms": 5
    },
    "neo4j": {
      "status": "up",
      "latency_ms": 12
    },
    "cache": {
      "status": "up",
      "entry_count": 1234
    }
  },
  "version": "8.3.0"
}
```

Status codes:
- 200 OK: All required checks pass
- 503 Service Unavailable: Any required check fails

B) METRICS (OPTIONAL, RECOMMENDED)

GET /metrics (Prometheus format)

May be deferred, but /healthz is REQUIRED for MVP.

C) READINESS VS LIVENESS

For Kubernetes deployments:
- /healthz → liveness probe (is app running?)
- /readyz → readiness probe (is app ready to serve traffic?)

MVP may use /healthz for both.

================================================================
32) NER/ER Completeness (No Stubs) — LOCKED

REQUIREMENT:
NER/ER modules MUST NOT be stubs if referenced as core features.

A) MINIMUM VIABLE NER

Dictionary + rules-first candidate extraction:

1. Issuer Program Registry Matches:
   - Exact match against known drug_program.name within issuer
   - Example: "KEYTRUDA" → existing drug_program_id

2. Open Targets Target/Disease Dictionaries:
   - ID-resolving exact matches only
   - Example: "EGFR" → ENSG00000146648 (via OpenTargets API)
   - Example: "breast cancer" → EFO_0000305 (via OpenTargets API)

3. Regex Heuristics:
   - Drug name patterns: [A-Z]{3,} (all caps, 3+ letters)
   - Target gene patterns: [A-Z]{2,}[0-9]* (EGFR, TP53)
   - Disease patterns: common disease terms dictionary

Outputs:
- nlp_run record (model_name, model_version, status)
- mention records (NER spans with offsets)
- candidate records (normalized suggestions, status='pending')
- evidence records (for provenance)

Guardrails (unchanged):
- NO canonical entity creation (drug_program, target, disease)
- NO auto-assertions
- Humans approve via curation workflow

B) MINIMUM VIABLE ER

Within-issuer-only duplicate suggestions:

1. DrugProgram Aliasing:
   - Find similar names within same issuer
   - Example: "Keytruda" vs "KEYTRUDA" vs "pembrolizumab"
   - Suggest merge candidates (status='pending')

2. No Automatic Merges:
   - ER only creates suggestions
   - Humans decide via curation workflow

3. Algorithm:
   - Exact match (case-insensitive)
   - Levenshtein distance < 3
   - Token overlap > 70%

C) ADVANCED MODELS (OPTIONAL, GATED)

SciSpacy/UMLS/ML models are OPTIONAL and MUST be:
- Behind feature flags (ENABLE_SCISPACY=true)
- License-checked (must pass license_allowlist)
- Human-approved (no auto canonical creation)
- Auditable (all suggestions logged)

D) IMPLEMENTATION STATUS

✅ COMPLETED (MVP v8.3)

NER/ER implementation complete with rules-first approach:
- run_ner_on_text(): Creates nlp_run, mention, candidate, evidence records
- extract_mentions(): Regex + dictionary extraction (drug names, targets, diseases)
- find_duplicates_for_issuer(): Within-issuer duplicate suggestions (Levenshtein + token overlap)
- Contract tests enforce guardrails (no canonical creation, no assertions, within-issuer only)

FORBIDDEN:
```python
# WRONG: Stub implementation
def run_ner_on_text(cursor, source_type, source_id, text, issuer_id):
    pass  # Empty stub is forbidden
```

NER/ER MUST produce auditable candidate outputs.

================================================================
33) Dependency Hygiene & Reproducible Builds — LOCKED

REQUIREMENT:
The deployed app must run from a single locked dependency file.

A) REQUIREMENTS FILE

Create requirements.txt (production dependencies):
```
# API framework
fastapi==0.109.0
uvicorn[standard]==0.27.0

# Database
psycopg[binary,pool]==3.1.17

# Authentication
python-jose[cryptography]==3.3.0

# Validation
pydantic==2.5.3
pydantic-settings==2.1.0

# HTTP clients (for integrations)
httpx==0.26.0

# Logging
structlog==24.1.0

# Configuration
python-dotenv==1.0.0
```

B) REQUIREMENTS VALIDATION

CI must validate:
1. Fresh install from requirements.txt
2. Fresh DB migrations (on empty database)
3. Contract tests pass
4. Full test suite passes
5. Server starts without errors

C) NO MISSING IMPORTS

All imports used by production entrypoint MUST be in requirements.txt.

Forbidden:
- Importing FastAPI but not listing it in requirements.txt
- Importing requests but not listing it
- Commenting out dependencies ("# requests>=2.31.0 # for PR4")

D) LOCK FILE (OPTIONAL, RECOMMENDED)

For reproducible builds:
- pip freeze > requirements.lock
- Deploy from requirements.lock (not requirements.txt)

E) DEVELOPMENT DEPENDENCIES

Separate file: requirements-dev.txt
```
# Testing
pytest>=7.4.0
pytest-asyncio>=0.21.0
pytest-cov>=4.1.0

# Code quality
black>=23.0.0
ruff>=0.1.0
mypy>=1.5.0

# NER/ER (if implemented)
spacy>=3.6.0
scispacy>=0.5.3
```

================================================================
34) Rate Limiting — SCOPED

RECOMMENDATION:
Enable rate limiting if hosted publicly.

A) SCOPE

If hosted publicly (no API key):
- Enable basic per-IP rate limiting
- Example: 100 requests/minute per IP

If hosted privately (API-key gated):
- Rate limiting MAY be deferred to later
- API keys themselves provide usage control

B) IMPLEMENTATION (OPTIONAL)

```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

@router.get("/api/v1/search")
@limiter.limit("10/minute")
async def search(query: str):
    ...
```

C) DEFERRED FOR MVP

Rate limiting is RECOMMENDED but NOT REQUIRED for MVP if:
- API is API-key gated (usage controlled via keys)
- Hosted privately (not public internet)

May be added in future iterations.

================================================================
35) Acceptance Criteria (Done Means) — LOCKED

DEFINITION:
BioGraph MVP is considered commercial-grade hosted POC ONLY when ALL criteria met.

A) API RUNTIME

✅ Exactly ONE API entrypoint is deployed
- /biograph/api/main.py (FastAPI)
- All legacy apps deleted or quarantined
- render.yaml references single entrypoint
- No ambiguity about which server to run

B) CI VALIDATION

✅ CI is green:
- Fresh database migrations (on empty DB)
- Contract tests pass (all 11+ contracts)
- Full test suite passes (unit + integration)
- No import errors
- Server starts without errors

C) SECURITY

✅ Admin/curation/raw endpoints are API-key gated
- /api/v1/admin/* requires X-API-Key
- /api/v1/curation/* requires X-API-Key
- Raw assertion/evidence bodies require X-API-Key
- 401 Unauthorized if missing/invalid key

D) INFRASTRUCTURE

✅ Connection pooling is enabled
- psycopg_pool in use
- Pool created at startup
- No per-request TCP connections
- Pool health checked in /healthz

E) ERROR HANDLING

✅ Errors are sanitized and structured
- No stack traces to clients
- JSON error format with request_id
- Proper HTTP status codes
- Structured logging (JSON logs)

F) OPERATIONAL

✅ /healthz endpoint works
- GET /healthz returns 200 or 503
- Verifies Postgres connectivity (required)
- Verifies Neo4j connectivity (if GRAPH_BACKEND=neo4j)
- Reports cache readiness

G) FEATURE COMPLETENESS

✅ NER/ER are not stubs
- Minimum viable NER produces candidates
- Minimum viable ER suggests duplicates
- Auditable outputs (nlp_run, mention, candidate records)
- Guardrails enforced (no auto canonical creation)

H) DEPENDENCY HYGIENE

✅ requirements.txt matches runtime imports
- All production imports listed
- No commented-out dependencies
- CI validates fresh install works
- No missing modules at runtime

I) DEPLOYMENT

✅ Hosted POC is running
- Deployed to Render (or equivalent)
- Environment variables configured
- Database migrations applied
- API accessible via HTTPS
- /healthz returns 200

J) DOCUMENTATION

✅ OpenAPI documentation available
- GET /docs (Swagger UI)
- GET /openapi.json (schema)
- All endpoints documented with examples

================================================================
END OF ADDENDUM
